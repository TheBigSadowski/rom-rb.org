<!DOCTYPE html><html><head><link href="/images/favicon.png" rel="icon" type="image/png" /><meta charset="utf-8" /><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><meta content="ROM &raquo; Guides &raquo; Mappers via @rom_rb" name="twitter:description" /><meta content="ROM &raquo; Guides &raquo; Mappers" name="description" /><title>ROM &raquo; Guides &raquo; Mappers</title><style type="text/css">.highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #d0d0d0;
  background-color: #151515;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}</style><link href="../../../stylesheets/all.css" rel="stylesheet" /><script src="../../../javascripts/all.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script><script>$(function() {
  var share = new Share(".share")
});
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-2573270-5', 'auto');
ga('send', 'pageview');</script></head><body class="guides guides_basics guides_basics_mappers guides_basics_mappers_index"><div class="page-wrapper"><header><nav class="navbar navbar-default navbar-static-top"><div class="navbar-inner"><div class="container"><a class="navbar-brand" href="/">Ruby Object Mapper</a><ul class="nav navbar-nav"><li class=""><a class="" href="/introduction">Introduction</a></li><li class=""><a class="" href="/guides">Guides</a></li><li class=""><a class="" href="/tutorials">Tutorials</a></li><li class="dropdown"><a class="dropdown-toggle" role="button" data-toggle="dropdown" href="#">API <span class='caret'/></a><ul class="dropdown-menu" role="menu"><li><a href="http://www.rubydoc.info/gems/rom">rom</a></li><li><a href="http://www.rubydoc.info/gems/rom-sql">rom-sql</a></li><li><a href="http://www.rubydoc.info/gems/rom-yesql">rom-yesql</a></li><li><a href="http://www.rubydoc.info/gems/rom-influxdb">rom-influxdb</a></li><li><a href="http://www.rubydoc.info/gems/rom-event_store">rom-event_store</a></li><li><a href="http://www.rubydoc.info/gems/rom-rethinkdb">rom-rethinkdb</a></li><li><a href="http://www.rubydoc.info/gems/rom-mongo">rom-mongo</a></li><li><a href="http://www.rubydoc.info/gems/rom-redis">rom-redis</a></li><li><a href="http://www.rubydoc.info/gems/rom-csv">rom-csv</a></li><li><a href="http://www.rubydoc.info/gems/rom-yaml">rom-yaml</a></li><li><a href="http://www.rubydoc.info/gems/rom-dm">rom-dm</a></li><li><a href="http://www.rubydoc.info/gems/rom-lotus">rom-lotus</a></li><li><a href="http://www.rubydoc.info/gems/rom-rails">rom-rails</a></li><li><a href="http://www.rubydoc.info/gems/rom-roda">rom-roda</a></li></ul></li><li class=""><a class="" href="/blog">Blog</a></li><li class=""><a class="" href="/contribute">Contribute</a></li><li class=""><a class="" href="/status">Status</a></li><li class=""><a class="" href="/backers">Backers <3</a></li></ul></div></div></nav></header><div class="container"><div class="content"><div class="row"><div class="col-md-3"><ul class="nav nav-pills nav-stacked"><li class="nav-heading"><a class="nav-heading" href="/guides/basics/setup">Setup</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/repositories">Repositories</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/relations">Relations</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/commands">Commands</a></li><li class="nav-heading active"><a class="nav-heading active" href="/guides/basics/mappers">Mappers</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/adapters">Adapters</a></li><li class=""><a class="" href="/guides/adapters/how-to">How-to</a></li><li class=""><a class="" href="/guides/adapters/sql">SQL</a></li><li class=""><a class="" href="/guides/adapters/cassandra">Cassandra</a></li></ul></div><div class="col-md-9"><div class="page-article"><h1 id="mappers">Mappers</h1>

<ul>
<li><a href="#purpose">Purpose</a></li>
<li><a href="#basic-usage">Basic Usage</a></li>
<li><a href="#mapping-strategies">Mapping Strategies</a>

<ul>
<li><a href="#lean-interface-to-domain">Lean Interface to Domain</a></li>
<li><a href="#rich-interface-to-domain">Rich Interface to Domain</a></li>
</ul></li>
<li><a href="#defining-and-using-mappers">Defining Mappers</a>

<ul>
<li><a href="#defining-a-mapper">Defining a Mapper</a></li>
<li><a href="#data-transformations">Data Transformations</a></li>
<li><a href="#applying-transformations-to-embedded-attributes">Applying Transformations to Embedded Attributes</a></li>
<li><a href="#applying-transformations-step-by-step">Applying Transformations Step by Step</a></li>
</ul></li>
<li><a href="#applying-and-reusing-mappers">Applying and Reusing Mappers</a>

<ul>
<li><a href="#applying-mappers-to-relations">Applying Mappers to Relations</a></li>
<li><a href="#chaining-mappers-to-pipeline">Chaining Mappers to Pipeline</a></li>
<li><a href="#subclassing-mappers">Subclassing Mappers</a></li>
<li><a href="#applying-mappers-to-nested-data">Applying Mappers to Nested Data</a></li>
</ul></li>
<li><a href="#custom-mappers">Custom Mappers</a></li>
</ul>

<h2 id="purpose">Purpose</h2>

<p>Every application needs different representations of the same data. Taking data
from one representation and converting it into another in ROM is done by using
mappers.</p>

<p>Even though <a href="/guides/basics/repositories/">Repository</a> supports automatic mapping
to structs, you may face situations where a customized mapping logic can be helpful.</p>

<p>Another great use-case for mappers is converting input into persistable form that
matches your database schema, which works great with <a href="/guides/basics/commands">commands</a>.</p>

<p>A mapper is an object that takes a relation and turns it into a domain-specific
collection which can include objects compatible with the domain interface. It can
return plain hashes or instantiate domain-specific models for you.</p>

<p>ROM provides a DSL to define mappers which can be integrated with 3rd-party
libraries.</p>

<p>Mapping is an extremely powerful concept. It can:</p>

<ul>
<li>Filter and rename attributes</li>
<li>Wrap and group attributes</li>
<li>Coerce values</li>
<li>Build aggregate objects</li>
<li>Build immutable value objects</li>
<li>And more&hellip;</li>
</ul>

<p>ROM also allows you to define mappers that can be reused for many relations, or
combined to create a pipeline.</p>

<h2 id="installation">Installation</h2>

<p>Mappers are part of <code>rom-mapper</code> gem which core <code>rom</code> gem depends on; however,
you can use mappers standalone, in that case simply install the gem:</p>
<pre class="highlight shell"><code>gem install rom-mapper
</code></pre>

<h2 id="basic-usage">Basic Usage</h2>

<p>With the adapter <a href="/guides/basics/relations">relations</a> raw data are extracted
from datasets and presented in a form of tuples.</p>
<pre class="highlight ruby"><code><span class="n">users</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">env</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span>
<span class="n">users</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># [</span>
<span class="c1">#   { id: 1, name: 'jane', email: 'jane@doo.org' },</span>
<span class="c1">#   { id: 2, name: 'john', email: 'john@doo.org' }</span>
<span class="c1"># ]</span>
</code></pre>

<p>Mappers convert tuples into the form required by the domain.</p>

<p>To create a mapper, first define the mapper for a relation.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserAsEntity</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">register_as</span> <span class="ss">:entity</span> <span class="c1"># the registered name of the mapper</span>
  <span class="n">relation</span> <span class="ss">:users</span>     <span class="c1"># the name of the relation the mapper is applicable to</span>
  <span class="n">model</span> <span class="no">User</span>          <span class="c1"># the domain model to map tuples to</span>
<span class="k">end</span>
</code></pre>

<p>After <a href="/guides/basics/setup">finalization</a> apply the mapper on the
dataset. Here we call <code>map_with</code> to apply the <code>UserAsEntity</code> mapper
(registered as <code>entity</code>) on the dataset:</p>
<pre class="highlight ruby"><code><span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:entity</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># [</span>
<span class="c1">#   &lt;User @id=1, @name='jane', @email='jane@doo.org'&gt;,</span>
<span class="c1">#   &lt;User @id=2, @name='john', @email='john@doo.org'&gt;</span>
<span class="c1"># ]</span>

<span class="c1"># The same result with the `map_with` alias method</span>
<span class="n">users</span><span class="p">.</span><span class="nf">map_with</span><span class="p">(</span><span class="ss">:entity</span><span class="p">).</span><span class="nf">to_a</span>
</code></pre>

<p>Mappers can also convert tuples returned from
<a href="/guides/basics/commands">commands</a>.</p>
<pre class="highlight ruby"><code><span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">env</span>

<span class="n">rom</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">create</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span>
  <span class="ss">id: </span><span class="mi">3</span><span class="p">,</span> <span class="ss">name: </span><span class="s1">'jack'</span><span class="p">,</span> <span class="ss">email: </span><span class="s1">'jack@doo.org'</span>
<span class="p">)</span>
<span class="c1"># { id: 3, name: 'jack', email: 'jack@doo.org' }</span>

<span class="n">rom</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">as</span><span class="p">(</span><span class="ss">:entity</span><span class="p">).</span><span class="nf">create</span><span class="p">(</span>
  <span class="ss">id: </span><span class="mi">4</span><span class="p">,</span> <span class="ss">name: </span><span class="s1">'joffrey'</span><span class="p">,</span> <span class="ss">email: </span><span class="s1">'joffrey@doo.org'</span>
<span class="p">)</span>
<span class="c1"># &lt;User @id=4, @name='jeff', @email='joffrey@doo.org'&gt;</span>
</code></pre>

<h2 id="mapping-strategies">Mapping Strategies</h2>

<p>Another example which comes up frequently is to map flat data into a nested model.</p>
<pre class="highlight ruby"><code><span class="n">users_with_roles</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">env</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">with_roles</span>
<span class="n">users_with_roles</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># [</span>
<span class="c1">#   { name: 'jane', role: 'admin' },</span>
<span class="c1">#   { name: 'jane', role: 'user'  },</span>
<span class="c1">#   { name: 'john', role: 'user'  }</span>
<span class="c1"># ]</span>
</code></pre>

<p>Suppose we need to convert it to list of domain users who each have many roles. There are two main strategies for doing this.</p>

<h3 id="1-lean-interface-to-domain">1. Lean Interface to Domain</h3>

<p>Under the first approach, the responsibility of the datastore is limited. It should provide query result as array of hashes, recognizable by the domain.</p>

<p>In this case the datastore is completely decoupled from the domain layer. It knows nothing about entities and their constructors.
The mapper is responsible for transforming source tuples to entity-friendly hashes.</p>

<p>In this example we will use the <code>group</code> syntax to group user roles.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserAsHash</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">register_as</span> <span class="ss">:hash</span>
  <span class="n">relation</span> <span class="ss">:users</span>

  <span class="n">attribute</span> <span class="ss">:name</span>
  <span class="n">group</span> <span class="ss">:roles</span> <span class="k">do</span>
    <span class="n">attribute</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">from: :role</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">options</span> <span class="o">=</span> <span class="n">users_with_roles</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:hash</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># [</span>
<span class="c1">#   { name: 'jane', roles: [{ title: 'admin' }, { title: 'user' }] },</span>
<span class="c1">#   { name: 'john', roles: [{ title: 'user' }] }</span>
<span class="c1"># ]</span>
</code></pre>

<p>Domain entities are responsible for instantiating their objects from mapper-provided hashes.</p>
<pre class="highlight ruby"><code><span class="nb">require</span> <span class="s1">'virtus'</span>

<span class="k">class</span> <span class="nc">Role</span>
  <span class="kp">include</span> <span class="no">Virtus</span><span class="p">.</span><span class="nf">model</span>

  <span class="n">attribute</span> <span class="ss">:title</span><span class="p">,</span> <span class="no">String</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">User</span>
  <span class="kp">include</span> <span class="no">Virtus</span><span class="p">.</span><span class="nf">model</span>

  <span class="n">attribute</span> <span class="ss">:name</span><span class="p">,</span>  <span class="no">String</span>
  <span class="n">attribute</span> <span class="ss">:roles</span><span class="p">,</span> <span class="no">Array</span><span class="p">[</span><span class="no">Role</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">jane</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">new</span> <span class="n">options</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># &lt;User @name='jane', @roles=[&lt;Role @title='admin'&gt;, &lt;Role @title='user'&gt;]&gt;</span>
<span class="n">john</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">new</span> <span class="n">options</span><span class="p">.</span><span class="nf">last</span>
<span class="c1"># &lt;User @name='john', @roles=[&lt;Role @title='user'&gt;]&gt;</span>
</code></pre>

<h3 id="2-rich-interface-to-domain">2. Rich Interface to Domain</h3>

<p>Under this second approach, the datastore provides query results as an array of pre-initialized domain objects.</p>

<p>By defining a mapper, you are specifying which entity class is going to be instantiated and what attributes are going to be used.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserAsEntity</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">register_as</span> <span class="ss">:entity</span>
  <span class="n">relation</span> <span class="ss">:users</span>

  <span class="n">model</span> <span class="no">User</span>

  <span class="n">attribute</span> <span class="ss">:name</span>
  <span class="n">group</span> <span class="ss">:roles</span> <span class="k">do</span>
    <span class="n">model</span> <span class="no">Role</span>

    <span class="n">attribute</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">from: :role</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Entity classes can be flat objects or aggregates defined separately from each other (depending on what you need).</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Role</span>
  <span class="kp">include</span> <span class="no">Virtus</span><span class="p">.</span><span class="nf">model</span>

  <span class="n">attribute</span> <span class="ss">:title</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">User</span>
  <span class="kp">include</span> <span class="no">Virtus</span><span class="p">.</span><span class="nf">model</span>

  <span class="n">attribute</span> <span class="ss">:name</span>
  <span class="n">attribute</span> <span class="ss">:roles</span> <span class="c1"># no coersion is needed here, this work is done by the mapper</span>
<span class="k">end</span>
</code></pre>

<p>With the mapper, the datastore adopts tuples directly to domain objects.</p>
<pre class="highlight ruby"><code><span class="n">options</span> <span class="o">=</span> <span class="n">users_with_roles</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:entity</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># [</span>
<span class="c1">#   &lt;User @name='jane', @roles=[&lt;Role @title='admin'&gt;, &lt;Role @title='user'&gt;]&gt;,</span>
<span class="c1">#   &lt;User @name='john', @roles=[&lt;Role @title='user'&gt;]&gt;</span>
<span class="c1"># ]</span>
</code></pre>

<p>This flexibility can simplify your domain layer quite a bit. You can design your domain objects exactly the way you want and configure mappings accordingly.</p>

<h2 id="defining-and-applying-mappers">Defining and Applying Mappers</h2>

<h3 id="defining-a-mapper">Defining a Mapper</h3>

<p>Like relations, mappers to be added to ROM environment during the
<a href="/guides/basics/setup">setup process</a>. You&rsquo;re free to declare
relations and mappers in any suitable order between invocations of
<code>ROM.setup</code> and <code>ROM.finalize</code>.</p>
<pre class="highlight ruby"><code><span class="n">setup</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">setup</span> <span class="ss">:memory</span>

<span class="c1"># This is when mappers should be registered in a sequence of loading</span>

<span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">finalize</span><span class="p">.</span><span class="nf">env</span>
</code></pre>

<p>To register a mapper you can follow any of two styles, that are analogous to the difference between Sinatra’s routing DSL and its modular application style.</p>

<p>In the &ldquo;routing-style&rdquo; DSL use the <code>setup.mappers</code> for adding a mapper:</p>
<pre class="highlight ruby"><code><span class="n">setup</span><span class="p">.</span><span class="nf">mappers</span> <span class="k">do</span>
  <span class="n">define</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">register_as</span> <span class="ss">:entity</span>

    <span class="n">model</span> <span class="no">User</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>In larger apps, we recommend configuring ROM with explicit class definitions. To do this you should explicitly inherit your mapper from <code>ROM::Mapper</code> base class. The following example does the same work as the previous one.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">EntityMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">register_as</span> <span class="ss">:entity</span>
  <span class="n">relation</span> <span class="ss">:users</span>

  <span class="n">model</span> <span class="no">User</span>
<span class="k">end</span>
</code></pre>

<p>As shown above, when defining a new mapper you need to set the registered name of the mapper and the name of the relation it is applicable to. The registered name of the mapper should be unique in a scope of the relation, so the following declarations are correct and do not conflict.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserEntityMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">register_as</span> <span class="ss">:entity</span>
  <span class="n">relation</span> <span class="ss">:users</span>

  <span class="n">model</span> <span class="no">User</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">TaskEntityMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">register_as</span> <span class="ss">:entity</span>
  <span class="n">relation</span> <span class="ss">:tasks</span>

  <span class="n">model</span> <span class="no">Task</span>
<span class="k">end</span>
</code></pre>

<h3 id="data-transformations">Data Transformations</h3>

<p>ROM mapper provides a rich DSL with a number of methods to transform the source into output domain objects. It supports:</p>

<ul>
<li><a href="filtering">Filtering Attributes</a></li>
<li><a href="renaming">Renaming Attributes</a></li>
<li><a href="wrapping">Wrapping Attributes</a></li>
<li><a href="grouping">Grouping Tuples</a></li>
<li><a href="folding">Folding Tuples</a></li>
<li><a href="combining">Combining Tuples from Several Relations</a></li>
<li><a href="models">Mapping Tuples to Models</a></li>
<li><a href="embedded">Embedded Attributes</a></li>
</ul>

<p>Below are some examples of the available transformations. For more details follow the corresponding link.</p>

<h4 id="filtering-attributes"><a href="filtering">Filtering Attributes</a></h4>

<p>You can either blacklist attributes:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UsersMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">exclude</span> <span class="ss">:password</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', password: '123456' }</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe' }</span>
</code></pre>

<p>&hellip;or whitelist them:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UsersMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">reject_keys</span> <span class="kp">true</span> <span class="c1"># Any keys not declared will be rejected</span>
  <span class="n">attribute</span> <span class="ss">:id</span>
  <span class="n">attribute</span> <span class="ss">:name</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', email: 'joe@example.com' }</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe' }</span>
</code></pre>

<h4 id="renaming-attributes"><a href="renaming">Renaming Attributes</a></h4>

<p>Attributes can be renamed:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UsersMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">symbolize_keys</span>
  <span class="n">attribute</span> <span class="ss">:login</span><span class="p">,</span> <span class="ss">from: :email</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># { 'id' =&gt; 1, 'name' =&gt; 'Joe', 'email' =&gt; 'joe@example.com' }</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', login: 'joe@example.com' }</span>
</code></pre>

<h4 id="wrapping-attributes"><a href="wrapping">Wrapping Attributes</a></h4>

<p>Attributes can be nested inside a new object.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UsersMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">wrap</span> <span class="ss">:contacts</span> <span class="k">do</span>
    <span class="n">attribute</span> <span class="ss">:email</span>
    <span class="n">attribute</span> <span class="ss">:skype</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', email: 'joe@example.com', skype:'joe' }</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', contacts: { email: 'joe@example.com', skype: 'joe' } }</span>
</code></pre>

<h4 id="unwrapping-tuples"><a href="unwrapping">Unwrapping Tuples</a></h4>

<p>Attributes can be pulled out of a nested object:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UsersMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">unwrap</span> <span class="ss">:contacts</span> <span class="k">do</span>
    <span class="n">attribute</span> <span class="ss">:email</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', contacts: { email: 'joe@example.com', skype: 'joe' } }</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', email: 'joe@example.com', contacts: { skype:'joe' } }</span>
</code></pre>

<h4 id="grouping-tuples"><a href="grouping">Grouping Tuples</a></h4>

<p>Objects can be grouped on certain attributes:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UsersMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">group</span> <span class="ss">:contacts</span> <span class="k">do</span>
    <span class="n">attribute</span> <span class="ss">:email</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># [</span>
<span class="c1">#   { id: 1, name: 'Joe', email: 'joe@example.com' },</span>
<span class="c1">#   { id: 1, name: 'Joe', email: 'joe@doe.org' }</span>
<span class="c1"># ]</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># [</span>
<span class="c1">#   {</span>
<span class="c1">#     id: 1, name: 'Joe', contacts: [</span>
<span class="c1">#       { email: 'joe@example.com' },</span>
<span class="c1">#       { email: 'joe@doe.org' }</span>
<span class="c1">#     ]</span>
<span class="c1">#   }</span>
<span class="c1"># ]</span>
</code></pre>

<h4 id="ungrouping-attributes"><a href="ungrouping">Ungrouping Attributes</a></h4>

<p>Objects can be ungrouped resulting in a flattened structure:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UsersMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">ungroup</span> <span class="ss">:contacts</span> <span class="k">do</span>
    <span class="n">attribute</span> <span class="ss">:email</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># [</span>
<span class="c1">#   {</span>
<span class="c1">#     id: 1, name: 'Joe', contacts: [</span>
<span class="c1">#       { email: 'joe@example.com' },</span>
<span class="c1">#       { email: 'joe@doe.org' }</span>
<span class="c1">#     ]</span>
<span class="c1">#   }</span>
<span class="c1"># ]</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># [</span>
<span class="c1">#   { id: 1, name: 'Joe', email: 'joe@example.com' },</span>
<span class="c1">#   { id: 1, name: 'Joe', email: 'joe@doe.org' }</span>
<span class="c1"># ]</span>
</code></pre>

<h4 id="folding-tuples"><a href="folding">Folding Tuples</a></h4>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UsersMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">fold</span> <span class="ss">:contacts</span> <span class="k">do</span>
    <span class="n">attribute</span> <span class="ss">:email</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># [</span>
<span class="c1">#   { id: 1, name: 'Joe', email: 'joe@example.com' },</span>
<span class="c1">#   { id: 1, name: 'Joe', email: 'joe@doe.org' }</span>
<span class="c1"># ]</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># [{ id: 1, name: 'Joe', contacts: ['joe@example.com', 'joe@doe.org'] }]</span>
</code></pre>

<h4 id="unfolding-attributes"><a href="unfolding">Unfolding Attributes</a></h4>

<p>Objects can be unfolded, resulting in a flattened structure:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UsersMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">unfold</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">from: :contacts</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># [{ id: 1, name: 'Joe', contacts: ['joe@example.com', 'joe@doe.org'] }]</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># [</span>
<span class="c1">#   { id: 1, name: 'Joe', email: 'joe@example.com' },</span>
<span class="c1">#   { id: 1, name: 'Joe', email: 'joe@doe.org' }</span>
<span class="c1"># ]</span>
</code></pre>

<h4 id="combining-tuples-from-several-relations"><a href="combining">Combining Tuples from Several Relations</a></h4>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Roles</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:memory</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">for_users</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
    <span class="n">restrict</span><span class="p">(</span><span class="ss">user_id: </span><span class="n">users</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">u</span><span class="o">|</span> <span class="n">u</span><span class="p">[</span><span class="ss">:id</span><span class="p">]</span> <span class="p">})</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">UsersMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">relation</span> <span class="ss">:users</span>
  <span class="n">register_as</span> <span class="ss">:with_roles</span>

  <span class="n">combine</span> <span class="ss">:roles</span><span class="p">,</span> <span class="ss">on: </span><span class="p">{</span> <span class="ss">id: :user_id</span> <span class="p">}</span> <span class="k">do</span>
    <span class="n">attribute</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">from: :role</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># [{ id: 1, name: 'Joe' }]</span>

<span class="n">roles</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># [{ user_id: 1, role: 'admin' }, { user_id: 1, role: 'manager' }]</span>

<span class="n">users_with_roles</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">combine</span><span class="p">(</span><span class="n">roles</span><span class="p">.</span><span class="nf">for_users</span><span class="p">).</span><span class="nf">as</span><span class="p">(</span><span class="ss">:user_with_roles</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># [{ id: 1, name: 'Joe', roles: [{ name: 'admin' }, { name: 'manager' }] }]</span>
</code></pre>

<h4 id="mapping-tuples-to-models"><a href="models">Mapping Tuples to Models</a></h4>

<p>The result of a mapping can be a model object, rather than a simple hash or array:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">model</span> <span class="no">User</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># [{ id: 1, name: 'Joe' }]</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># [#&lt;User @id=1, @name='Joe'&gt;]</span>
</code></pre>

<h4 id="embedded-attributes"><a href="embedded">Embedded Attributes</a></h4>

<p>Suppose we have a source with a deeply nested data to transform:</p>
<pre class="highlight ruby"><code><span class="n">users</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">env</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span>
<span class="n">users</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># {</span>
<span class="c1">#   list_id: 1,</span>
<span class="c1">#   list_tasks: [</span>
<span class="c1">#     { user: 'Jacob', task_id: 1, task_title: 'be nice'    },</span>
<span class="c1">#     { user: 'Jacob', task_id: 2, task_title: 'sleep well' }</span>
<span class="c1">#   ]</span>
<span class="c1"># }</span>
</code></pre>

<p>With the help of <code>embedded</code> we could apply transformations to the necessary level of nesting:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">relation</span> <span class="ss">:users</span>
  <span class="n">register_as</span> <span class="ss">:users</span>

  <span class="n">embedded</span> <span class="ss">:list_tasks</span><span class="p">,</span> <span class="ss">type: :array</span> <span class="k">do</span>
    <span class="n">group</span> <span class="ss">:tasks</span><span class="p">,</span> <span class="ss">prefix: </span><span class="s1">'task'</span> <span class="k">do</span>
      <span class="n">attribute</span> <span class="ss">:id</span>
      <span class="n">attribute</span> <span class="ss">:title</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># {</span>
<span class="c1">#   list_id: 1,</span>
<span class="c1">#   list_tasks: [</span>
<span class="c1">#     {</span>
<span class="c1">#       user: 'Jacob', tasks: [</span>
<span class="c1">#         { id: 1, title: 'be nice' },</span>
<span class="c1">#         { id: 2, title: 'sleep well' }</span>
<span class="c1">#       ]</span>
<span class="c1">#     }</span>
<span class="c1">#   ]</span>
<span class="c1"># }</span>
</code></pre>

<p>See <a href="embedding.md">Embedding Transformations</a> for further details.</p>

<h3 id="applying-transformations-step-by-step">Applying Transformations Step by Step</h3>

<p>Various transformations can be applied by mappers step-by-step. This allows a mapper to take deeply nested data from source, rearrange them and provide any required output.</p>

<p>Suppose the relation returns the following data:</p>
<pre class="highlight ruby"><code><span class="n">users</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">env</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span>
<span class="n">users</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># {</span>
<span class="c1">#   list_id: 1,</span>
<span class="c1">#   list_tasks: [</span>
<span class="c1">#     { user: 'Jacob', task_id: 1, task_title: 'be nice'    },</span>
<span class="c1">#     { user: 'Jacob', task_id: 2, task_title: 'sleep well' }</span>
<span class="c1">#   ]</span>
<span class="c1"># }</span>
</code></pre>

<p>With the sequence of several <code>step</code>-s we can perform a series of complex tranformations inside one mapper:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">relation</span> <span class="ss">:users</span>
  <span class="n">register_as</span> <span class="ss">:users</span>

  <span class="n">step</span> <span class="k">do</span>
    <span class="n">prefix</span> <span class="s1">'list'</span>
    <span class="n">attribute</span> <span class="ss">:id</span>
    <span class="n">unfold</span> <span class="ss">:tasks</span>
  <span class="k">end</span>

  <span class="n">step</span> <span class="k">do</span>
    <span class="n">unwrap</span> <span class="ss">:tasks</span> <span class="k">do</span>
      <span class="n">attribute</span> <span class="ss">:task_id</span>
      <span class="n">attribute</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">from: :user</span>
      <span class="n">attribute</span> <span class="ss">:task_title</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">step</span> <span class="k">do</span>
    <span class="n">group</span> <span class="ss">:tasks</span> <span class="k">do</span>
      <span class="n">prefix</span> <span class="s1">'task'</span>
      <span class="n">attribute</span> <span class="ss">:id</span>
      <span class="n">attribute</span> <span class="ss">:title</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">step</span> <span class="k">do</span>
    <span class="n">wrap</span> <span class="ss">:user</span> <span class="k">do</span>
      <span class="n">attribute</span> <span class="ss">:name</span>
      <span class="n">attribute</span> <span class="ss">:tasks</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>The mapper will provide the output as following:</p>
<pre class="highlight ruby"><code><span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># {</span>
<span class="c1">#   id: 1,</span>
<span class="c1">#   user: {</span>
<span class="c1">#     name: 'Jacob',</span>
<span class="c1">#     tasks: [</span>
<span class="c1">#       { id: 1, title: 'be nice'    },</span>
<span class="c1">#       { id: 2, title: 'sleep well' }</span>
<span class="c1">#     ]</span>
<span class="c1">#   }</span>
<span class="c1"># }</span>
</code></pre>

<p>Look at the <a href="sequencing">corresponding subsection</a> for further details.</p>

<h2 id="using-and-reusing-mappers">Using and Reusing Mappers</h2>

<h3 id="applying-mappers-to-relations">Applying Mappers to Relations</h3>

<p>After finalizing ROM, apply the mapper to a relation with the <code>as</code> method, or its alias <code>map_with</code>, using the registered name of the mapper:</p>
<pre class="highlight ruby"><code><span class="n">users</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">env</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span> <span class="c1"># returns lazy relation</span>
<span class="n">users</span><span class="p">.</span><span class="nf">first</span> <span class="c1"># returns the first record from the raw data</span>
<span class="c1"># =&gt; { id: 1, name: 'Joe' }</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:entity</span><span class="p">).</span><span class="nf">first</span> <span class="c1"># the record mapped to the User model</span>
<span class="c1"># =&gt; #&lt;User @id=1, @name='Joe'&gt;</span>

<span class="n">users</span><span class="p">.</span><span class="nf">map_with</span><span class="p">(</span><span class="ss">:entity</span><span class="p">).</span><span class="nf">first</span> <span class="c1"># the alternative syntax</span>
</code></pre>

<p>Like <a href="/buides/basics/relations#lazy-relations">relations</a>, <strong>mappers are applied lazily</strong> which allows you to compose relations and mappers together in an arbitrary order in the data pipeline. All the following definitions do the same thing:</p>
<pre class="highlight ruby"><code><span class="n">users</span><span class="p">.</span><span class="nf">with_tasks</span><span class="p">.</span><span class="nf">with_tags</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:entity</span><span class="p">)</span>
<span class="n">users</span><span class="p">.</span><span class="nf">with_tasks</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:entity</span><span class="p">).</span><span class="nf">with_tags</span>
<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:entity</span><span class="p">).</span><span class="nf">with_tasks</span><span class="p">.</span><span class="nf">with_tags</span>
</code></pre>

<h2 id="reusing-mappers">Reusing Mappers</h2>

<h3 id="the-data-pipeline">The Data Pipeline</h3>

<p>Mappers can be applied to source data one-by-one. This is especially useful when you map data from various sources with different data structure. With the help of chaining you can adopt sources to common interface with adapter-specific mappers, and then apply the adapter-agnostic mapper to their outputs.</p>
<pre class="highlight plaintext"><code>db adapter -&gt;
  relation(:users) -&gt;
    mappers(:adapter_specific) -&gt;
      mappers(:adapter_agnostic) -&gt; domain
</code></pre>

<p>To do this you can list mappers as arguments of <code>as</code> (or <code>map_with</code>) method in the required order:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">NestingMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">register_as</span> <span class="ss">:nested</span>
  <span class="n">relation</span> <span class="ss">:users</span>

  <span class="n">wrap</span> <span class="ss">:contacts</span> <span class="k">do</span>
    <span class="n">attribute</span> <span class="ss">:email</span>
    <span class="n">attribute</span> <span class="ss">:skype</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">EntityMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">register_as</span> <span class="ss">:entity</span>
  <span class="n">relation</span> <span class="ss">:users</span>

  <span class="n">model</span> <span class="no">User</span>
<span class="k">end</span>

<span class="n">users</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">finalize</span><span class="p">.</span><span class="nf">env</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span>

<span class="n">users</span><span class="p">.</span><span class="nf">first</span> <span class="c1"># the raw data</span>
<span class="c1"># { id: 1, name: 'Joe', email: 'joe@example.com', skype: 'joe' }</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:nested</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', contacts: { email: 'joe@example.com', skype: 'joe' } }</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:nested</span><span class="p">,</span> <span class="ss">:entity</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># #&lt;User @id=1, @name='Joe' @contacts={ email: 'joe@example.com', skype: 'joe' }&gt;</span>
</code></pre>

<h3 id="subclassing-mappers">Subclassing Mappers</h3>

<p>To keep your code <a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>, mappers can be <em>subclassed</em> from existing mappers to customize it for slightly different output.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">FirstMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">register_as</span> <span class="ss">:first</span>
  <span class="n">relation</span> <span class="ss">:users</span>

  <span class="n">attribute</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">from: :contact_email</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">SecondMapper</span> <span class="o">&lt;</span> <span class="no">FirstMapper</span>
  <span class="n">register_as</span> <span class="ss">:second</span>
  <span class="n">relation</span> <span class="ss">:users</span>

  <span class="n">attribute</span> <span class="ss">:skype</span><span class="p">,</span> <span class="ss">from: :contact_skype</span>
<span class="k">end</span>

<span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">finalize</span><span class="p">.</span><span class="nf">env</span>
<span class="n">users</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span>

<span class="n">users</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', contact_email: 'joe@email.com', contact_skype: 'joe' }</span>
<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:first</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', email: 'joe@email.com', contact_skype: 'joe' }</span>
<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:second</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', email: 'joe@email.com', skype: 'joe' }</span>
</code></pre>

<p>Use this feature with care. There are <a href="reusing">some edge cases you should take into account</a>.</p>

<h3 id="applying-mappers-to-nested-data">Applying Mappers to Nested Data</h3>

<p>Another way to make the code DRY is to apply reusable mapper to nested group of fields (either <code>group</code> or <code>wrap</code>).</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ContactMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">register_as</span> <span class="ss">:contact</span>
  <span class="n">relation</span> <span class="ss">:users</span>

  <span class="n">attribute</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">from: :contact_email</span>
  <span class="n">attribute</span> <span class="ss">:skype</span><span class="p">,</span> <span class="ss">from: :contact_skype</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">UserMapper</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Mapper</span>
  <span class="n">register_as</span> <span class="ss">:nested_hash</span>
  <span class="n">relation</span> <span class="ss">:users</span>

  <span class="n">wrap</span> <span class="ss">:contacts</span><span class="p">,</span> <span class="ss">mapper: </span><span class="no">ContactMapper</span>
<span class="k">end</span>

<span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">finalize</span><span class="p">.</span><span class="nf">env</span>
<span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', contact_email: 'joe@email.com', contact_skype: 'joe' }</span>
<span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">as</span><span class="p">(</span><span class="ss">:nested_hash</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># { id: 1, name: 'Joe', contacts: { email: 'joe@email.com', skype: 'joe' } }</span>
</code></pre>

<p>With this feature you can <em>extract</em> common transformations, and share them between various mappers.</p>

<p>Use it with some care! There are <a href="wrapping#applying-another-mapper">edge cases you should take into account</a>.</p>

<h2 id="custom-mappers">Custom Mappers</h2>

<p>ROM allows custom coercer objects to be registered as mappers. Any object, that responds to <code>#call</code> method with one argument can be registered as a ROM mapper.</p>

<p>To register an arbitrary mapper, use the following syntax:</p>
<pre class="highlight ruby"><code><span class="n">arbitrary_mapper</span> <span class="o">=</span> <span class="o">-&gt;</span> <span class="n">users</span> <span class="p">{</span> <span class="n">users</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">tuple</span><span class="o">|</span> <span class="n">tuple</span><span class="p">[</span><span class="ss">:id</span><span class="p">]</span> <span class="p">}</span> <span class="p">}</span>

<span class="n">setup</span><span class="p">.</span><span class="nf">mappers</span> <span class="k">do</span>
  <span class="n">register</span><span class="p">(</span><span class="ss">:users</span><span class="p">,</span> <span class="ss">external: </span><span class="n">arbitrary_mapper</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>

<p>The mapper will be applied to the whole output of a corresponding relation:</p>
<pre class="highlight ruby"><code><span class="n">users</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">env</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span>
<span class="n">users</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [{ id: 1, name: 'Jane' }, { id: 2, name: 'Joe' }, { id: 3, name: 'John'}]</span>

<span class="n">users</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:external</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [1, 2]</span>
</code></pre>
<div class="page-article-edit"><hr /><div class="share pull-left"></div><p class="pull-right">Edit this article on <a href="https://github.com/rom-rb/rom-rb.org/tree/master/source/doc-pages/guides/basics/mappers.md">GitHub</a></p></div></div></div></div></div></div></div><footer><div class="container"><div class="social"><div class="github"><iframe allowtransparency="true" frameborder="0" height="20" scrolling="0" src="http://ghbtns.com/github-btn.html?user=rom-rb&repo=rom&type=watch&count=true" width="110"></iframe></div><div class="twitter"><a class="twitter-follow-button" data-show-count="true" data-show-screen-name="false" href="https://twitter.com/rom_rb">Follow</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></div></div><div class="muted copyright">Ruby Object Mapper &copy; 2014-2015</div></div></footer></body></html>